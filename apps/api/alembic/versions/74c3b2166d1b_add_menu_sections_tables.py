"""add menu sections tables

Revision ID: 74c3b2166d1b
Revises: 6c9e94f07973
Create Date: 2025-10-30 12:00:00.000000

"""
from __future__ import annotations

from collections import defaultdict
from typing import Any, Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = "74c3b2166d1b"
down_revision: Union[str, None] = "6c9e94f07973"
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


MENU_SECTION_TABLE = "menu_section"
MENU_SECTION_RECIPE_TABLE = "menu_section_recipe"
ARCHIVE_SECTION_NAME = "Archive"
UNCATEGORISED_NAME = "Uncategorized"


def _clean_section_name(raw: Any) -> str:
    if raw is None:
        return UNCATEGORISED_NAME
    if isinstance(raw, str):
        cleaned = raw.strip()
        return cleaned or UNCATEGORISED_NAME
    return str(raw)


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table(
        MENU_SECTION_TABLE,
        sa.Column("id", sa.Integer(), autoincrement=True, nullable=False),
        sa.Column("menu_id", sa.Integer(), nullable=False),
        sa.Column("name", sa.Text(), nullable=False),
        sa.Column("position", sa.Integer(), nullable=True),
        sa.Column("created_at", sa.TIMESTAMP(), server_default=sa.text("CURRENT_TIMESTAMP"), nullable=False),
        sa.ForeignKeyConstraint(["menu_id"], ["menu.id"], ),
        sa.PrimaryKeyConstraint("id"),
        sa.UniqueConstraint("menu_id", "name", name="uq_menu_section_menu_name"),
    )
    op.create_index("ix_menu_section_menu_id", MENU_SECTION_TABLE, ["menu_id"], unique=False)
    op.create_table(
        MENU_SECTION_RECIPE_TABLE,
        sa.Column("section_id", sa.Integer(), nullable=False),
        sa.Column("recipe_id", sa.Integer(), nullable=False),
        sa.Column("position", sa.Integer(), nullable=True),
        sa.ForeignKeyConstraint(["recipe_id"], ["recipe.id"], ),
        sa.ForeignKeyConstraint(["section_id"], [MENU_SECTION_TABLE + ".id"], ),
        sa.PrimaryKeyConstraint("section_id", "recipe_id"),
    )
    op.create_index(
        "ix_menu_section_recipe_section_id",
        MENU_SECTION_RECIPE_TABLE,
        ["section_id"],
        unique=False,
    )
    op.create_index(
        "ix_menu_section_recipe_recipe_id",
        MENU_SECTION_RECIPE_TABLE,
        ["recipe_id"],
        unique=False,
    )
    # ### end Alembic commands ###

    bind = op.get_bind()
    metadata = sa.MetaData()
    metadata.reflect(
        bind=bind,
        only={"menu", "recipe", "menu_recipe", MENU_SECTION_TABLE, MENU_SECTION_RECIPE_TABLE},
    )

    menu_table = metadata.tables["menu"]
    recipe_table = metadata.tables["recipe"]
    menu_recipe_table = metadata.tables.get("menu_recipe")
    menu_section_table = metadata.tables[MENU_SECTION_TABLE]
    menu_section_recipe_table = metadata.tables[MENU_SECTION_RECIPE_TABLE]

    # When starting from a clean database (no menu_recipe table yet) the reflection above
    # will not include it. Skip the migration step in that case.
    if menu_recipe_table is not None:
        section_lookup: dict[int, dict[str, int]] = defaultdict(dict)
        section_positions: dict[int, int] = defaultdict(int)

        menu_rows = bind.execute(sa.select(menu_table.c.id)).fetchall()
        menu_ids = [row[0] for row in menu_rows]

        for menu_id in menu_ids:
            section_positions[menu_id] = 0

        join_stmt = (
            sa.select(
                menu_recipe_table.c.menu_id,
                menu_recipe_table.c.recipe_id,
                menu_recipe_table.c.position,
                recipe_table.c.menu_category,
            )
            .select_from(
                menu_recipe_table.join(
                    recipe_table,
                    menu_recipe_table.c.recipe_id == recipe_table.c.id,
                )
            )
            .order_by(
                menu_recipe_table.c.menu_id.asc(),
                sa.case(
                    (menu_recipe_table.c.position.is_(None), 1),
                    else_=0,
                ),
                menu_recipe_table.c.position.asc(),
                menu_recipe_table.c.recipe_id.asc(),
            )
        )

        rows = bind.execute(join_stmt).fetchall()

        for menu_id, recipe_id, recipe_position, raw_category in rows:
            normalised_name = _clean_section_name(raw_category)
            name_key = normalised_name.lower()

            menu_map = section_lookup[menu_id]
            section_id = menu_map.get(name_key)

            if section_id is None:
                next_position = section_positions[menu_id]
                section_positions[menu_id] = next_position + 1
                insert_result = bind.execute(
                    menu_section_table.insert()
                    .values(
                        menu_id=menu_id,
                        name=normalised_name,
                        position=next_position,
                    )
                    .returning(menu_section_table.c.id)
                )
                section_id = insert_result.scalar_one()
                menu_map[name_key] = section_id

            bind.execute(
                menu_section_recipe_table.insert().values(
                    section_id=section_id,
                    recipe_id=recipe_id,
                    position=recipe_position,
                )
            )

        # Ensure every menu has an archive section
        for menu_id in menu_ids:
            menu_map = section_lookup[menu_id]
            if ARCHIVE_SECTION_NAME.lower() in menu_map:
                continue

            insert_result = bind.execute(
                menu_section_table.insert()
                .values(
                    menu_id=menu_id,
                    name=ARCHIVE_SECTION_NAME,
                    position=9999,
                )
                .returning(menu_section_table.c.id)
            )
            menu_map[ARCHIVE_SECTION_NAME.lower()] = insert_result.scalar_one()
    else:
        # Clean databases still need an archive section per menu
        menu_rows = bind.execute(sa.select(menu_table.c.id)).fetchall()
        for (menu_id,) in menu_rows:
            bind.execute(
                menu_section_table.insert().values(
                    menu_id=menu_id,
                    name=ARCHIVE_SECTION_NAME,
                    position=9999,
                )
            )

    if menu_recipe_table is not None:
        op.drop_table("menu_recipe")

    with op.batch_alter_table("recipe", schema=None) as batch_op:
        batch_op.drop_column("menu_category")


def downgrade() -> None:
    # Recreate menu_category column
    with op.batch_alter_table("recipe", schema=None) as batch_op:
        batch_op.add_column(sa.Column("menu_category", sa.Text(), nullable=True))

    op.create_table(
        "menu_recipe",
        sa.Column("menu_id", sa.Integer(), nullable=False),
        sa.Column("recipe_id", sa.Integer(), nullable=False),
        sa.Column("position", sa.Integer(), nullable=True),
        sa.ForeignKeyConstraint(["menu_id"], ["menu.id"], ),
        sa.ForeignKeyConstraint(["recipe_id"], ["recipe.id"], ),
        sa.PrimaryKeyConstraint("menu_id", "recipe_id"),
    )

    bind = op.get_bind()
    metadata = sa.MetaData()
    metadata.reflect(bind=bind, only={"menu", "recipe", MENU_SECTION_TABLE, MENU_SECTION_RECIPE_TABLE, "menu_recipe"})

    menu_table = metadata.tables["menu"]
    recipe_table = metadata.tables["recipe"]
    menu_recipe_table = metadata.tables["menu_recipe"]
    menu_section_table = metadata.tables[MENU_SECTION_TABLE]
    menu_section_recipe_table = metadata.tables[MENU_SECTION_RECIPE_TABLE]

    # Restore menu_category data for recipes based on their first section assignment
    join_stmt = (
        sa.select(
            menu_section_recipe_table.c.recipe_id,
            menu_section_table.c.menu_id,
            menu_section_table.c.name,
            menu_section_table.c.position,
            menu_section_recipe_table.c.position.label("recipe_position"),
        )
        .select_from(
            menu_section_recipe_table.join(
                menu_section_table,
                menu_section_recipe_table.c.section_id == menu_section_table.c.id,
            )
        )
    )

    rows = bind.execute(join_stmt).fetchall()

    # Determine primary section per recipe (prefer lowest section position, then recipe position)
    recipe_section: dict[int, tuple[str, int, int]] = {}
    inserted_pairs: set[tuple[int, int]] = set()
    for recipe_id, menu_id, section_name, section_position, recipe_position in rows:
        if section_name.lower() == ARCHIVE_SECTION_NAME.lower():
            continue

        current = recipe_section.get(recipe_id)
        candidate = (
            section_name,
            section_position if section_position is not None else 9999,
            recipe_position if recipe_position is not None else 9999,
        )

        if current is None or (candidate[1], candidate[2]) < (current[1], current[2]):
            recipe_section[recipe_id] = candidate

        key = (menu_id, recipe_id)
        if key in inserted_pairs:
            continue
        inserted_pairs.add(key)

        bind.execute(
            menu_recipe_table.insert().values(
                menu_id=menu_id,
                recipe_id=recipe_id,
                position=recipe_position,
            )
        )

    for recipe_id, (section_name, *_rest) in recipe_section.items():
        bind.execute(
            recipe_table.update()
            .where(recipe_table.c.id == recipe_id)
            .values(menu_category=section_name)
        )

    op.drop_index("ix_menu_section_recipe_recipe_id", table_name=MENU_SECTION_RECIPE_TABLE)
    op.drop_index("ix_menu_section_recipe_section_id", table_name=MENU_SECTION_RECIPE_TABLE)
    op.drop_table(MENU_SECTION_RECIPE_TABLE)
    op.drop_index("ix_menu_section_menu_id", table_name=MENU_SECTION_TABLE)
    op.drop_table(MENU_SECTION_TABLE)
    # ### end Alembic commands ###
